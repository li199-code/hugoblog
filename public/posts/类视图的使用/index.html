<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.119.0">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>类视图的使用 &middot; JasonLee</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.jasonleehere.com/"><h1>JasonLee</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.jasonleehere.com/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2023. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>类视图的使用</h1>
  <time datetime=2023-05-01T10:07:54Z class="post-date">Mon, May 1, 2023</time>
  <h2 id="前言">前言</h2>
<p>对于类视图和函数视图，在我初学django的时，有过这样的迷思：自己定义的类视图似乎和函数视图没有太大的区别，无非就是判断请求方式的时候，CBV用函数，FBV用<code>if...else...</code>。而如果上了框架提供的通用类视图，代码风格似乎过于抽象，且不灵活，无法完全替代函数视图。今天，就以刚刚用函数视图完成的项目为例，尝试将所有函数视图转为类视图，看看过程中有什么新的感悟。</p>
<h2 id="通用类视图里的方法">通用类视图里的方法</h2>
<h3 id="添加额外的上下文">添加额外的上下文：</h3>
<pre tabindex="0"><code>def get_context_data(self, **kwargs):
    # Call the base implementation first to get a context
    context = super().get_context_data(**kwargs)
    # Add in a QuerySet of all the books
    context[&#34;book_list&#34;] = Book.objects.all()
    return context
</code></pre><h3 id="根据url内传来的query参数来动态查询">根据url内传来的query参数来动态查询</h3>
<p>这项工作的关键部分是当基于类的视图被调用的时候，各种常用的东西被存储在 self 上，而且请求 (self.request) 根据 URLconf 抓取位置(self.args) 和基于名称 (self.kwargs) 的参数。</p>
<pre tabindex="0"><code>def get_queryset(self):
    self.publisher = get_object_or_404(Publisher, name=self.kwargs[&#34;publisher&#34;])
    return Book.objects.filter(publisher=self.publisher)
</code></pre><h3 id="执行额外的任务">执行额外的任务</h3>
<pre tabindex="0"><code>class AuthorDetailView(DetailView):
    queryset = Author.objects.all()

    def get_object(self):
        obj = super().get_object()
        # Record the last accessed date
        obj.last_accessed = timezone.now()
        obj.save()
        return obj
</code></pre><h2 id="通用类视图到底为开发者默认做了哪些事">通用类视图到底为开发者默认做了哪些事</h2>
<p>django框架内置的通用类视图之所以能少些很多代码，很明显是它有一些默认行为。那么这里就记录一下各种常见内置视图的默认行为。</p>
<h3 id="formview">FormView</h3>
<pre tabindex="0"><code>class ContactFormView(FormView):
    template_name = &#34;contact.html&#34;
    form_class = ContactForm
    success_url = &#34;/thanks/&#34;

    def form_valid(self, form):
        # This method is called when valid form data has been POSTed.
        # It should return an HttpResponse.
        form.send_email()
        return super().form_valid(form)
</code></pre><p>表单视图的一般行为是判断请求方式，如果是post，就检验字段有效性，且把错误返回给浏览器，成功则重定向；如果是get就返回待填写的表单。</p>
<p>所以，FormView就是通过暴露一些简单的配置给开发者，比如template_name，其他行为会自动完成。如果有特殊需求，重写get或post方法。form_valid是执行表单验证之后的程序。</p>
<p>form_valid函数是一定要重写的，这也说明django文档里一般都是最小实现形式，不能减少。</p>
<h2 id="总结">总结</h2>
<ul>
<li>类视图完全可以替代函数视图。</li>
<li>优先用内置的通用类视图，首先确认任务类型，如果是展示类，就考虑ListView、DetailVIew；如果是修改类，就是CreateView、UpdateView、DeleteView。</li>
<li>修改类的通用视图，注意表单相关项。运用上面提到的三个函数，可以实现较复杂的需求。</li>
<li>如果不方便，也可以不用内置视图，而采用根据请求方式划分方法，比如get请求。</li>
<li>类视图在采用了内置类的写法后，代码会变少；但更重要的意义是，增加了代码重用的可能性。比如，另外一个views.py可以继承过来。</li>
</ul>

</div>


    </main>

    
      
    
  </body>
</html>
