<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.119.0">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>sklearn crash course &middot; JasonLee</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.jasonleehere.com/"><h1>JasonLee</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.jasonleehere.com/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2023. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>sklearn crash course</h1>
  <time datetime=2023-09-24T23:06:24Z class="post-date">Sun, Sep 24, 2023</time>
  <h2 id="前言">前言</h2>
<p>油管<a href="https://www.youtube.com/watch?v=0B5eIE_1vpU&amp;ab_channel=freeCodeCamp.org">视频教程</a>。想到哪儿写到哪儿。</p>
<h2 id="如何让-jupyter-notebook-切换到-venv-环境">如何让 jupyter notebook 切换到 venv 环境</h2>
<p><a href="">参考链接</a></p>
<p>首先在虚拟环境下的 cmd 中运行：</p>
<pre tabindex="0"><code>pip install ipykernel
</code></pre><p>然后，在在虚环境中将当前的虚拟环境添加到 Jupyter Notebook 的 kernel 中：</p>
<pre tabindex="0"><code>python -m ipykernel install --name 虚环境名称 --display-name 虚环境名称 --user
</code></pre><h2 id="框架">框架</h2>
<p><img src="https://fastly.jsdelivr.net/gh/li199-code/blog-imgs@main/16955688583221695568857524.png" alt="16955688583221695568857524.png"></p>
<p>上图是用 sklearn 完成机器学习任务的一般框架。首先数据类型分为特征（X）和标签（y）。pipeline（管道、流程）包含数据归一化（preprocessing 的一种）和模型（model）。pipeline 有两个重要 api：fit 和 predict，前者训练，后者测试。</p>
<p>如果要确定超参数的值，且训练数据有限的情况下，需要用交叉验证（Cross validation, CV）。用法是：</p>
<pre tabindex="0"><code>mod = GridSearchCV(estimator=pipe, param_grid={
    &#39;model__n_neighbors&#39;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    },
    cv=3)
</code></pre><p>其中，estimator 是 pipeline 或者 model，param_grid 是需要确定的超参数，是一个字典，键是&rsquo;model__[name]&lsquo;的格式，cv 表示要将数据分为几折来进行交叉验证。</p>
<p>完整代码如下：</p>
<pre tabindex="0"><code>from sklearn.datasets import load_boston
from sklearn.neighbors import KNeighborsRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.model_selection import GridSearchCV
import pandas as pd

mod = GridSearchCV(estimator=pipe, param_grid={
    &#39;model__n_neighbors&#39;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    },
    cv=3)
mod.fit(X, y);

## 查看交叉验证的结果
pd.DataFrame(mod.cv_results_)
</code></pre><h2 id="预处理">预处理</h2>
<p>视频以一个存在离群点的场景为例，说明预处理措施的作用。离群点会导致模型预测的偏差。</p>
<p><img src="https://fastly.jsdelivr.net/gh/li199-code/blog-imgs@main/16956472633051695647262551.png" alt="16956472633051695647262551.png"></p>
<p>最容易想到的预处理方式是正态分布化，但是离群点问题仍然存在。因此，采用一种均匀分布方法：QuantileTransformer。</p>
<p><img src="https://fastly.jsdelivr.net/gh/li199-code/blog-imgs@main/16956474313051695647430838.png" alt="16956474313051695647430838.png"></p>
<p>可以看出，离群点不明显了。</p>
<p>另外，增加特征的维数（PolynomialFeatures）也在预处理范畴内。增加特征维数可以更好地捕获数据中的特征关系。</p>
<p>最后介绍了 One Hot Encoding，一种经典的将文本数据转为数值特征（标签）的预处理措施。</p>
<p>总结一下，sklearn 中，调用预处理措施的格式是：<code>Transformer().fit_transform(data)</code>.</p>
<h2 id="指标">指标</h2>
<p>precision_score：分母是模型预测为正类的个数，分子是模型预测正类<strong>正确</strong>的个数。</p>
<p>recall_score: 分母是样本中所有正类的个数，分子是分母中模型预测正类<strong>正确</strong>的个数。</p>
<p>GridSearchCV （或者 model 和 pipeline）可以使用 scoring 来自定义目标函数。而自定义的损失函数需要 make_scorer 生成。</p>
<pre tabindex="0"><code>from sklearn.model_selection import GridSearchCV
from sklearn.metrics import precision_score, recall_score, make_scorer

def min_recall_precision(est, X, y_true, sample_weight=None):
    y_pred = est.predict(X)
    recall = recall_score(y_true, y_pred)
    precision = precision_score(y_true, y_pred)
    return min(recall, precision)

grid = GridSearchCV(
    estimator=LogisticRegression(max_iter=1000),
    param_grid={&#39;class_weight&#39;: [{0: 1, 1: v} for v in np.linspace(1, 20, 30)]},
    scoring={&#39;precision&#39;: make_scorer(precision_score),
             &#39;recall&#39;: make_scorer(recall_score),
             &#39;min_both&#39;: min_recall_precision},
    refit=&#39;min_both&#39;,
    return_train_score=True,
    cv=10,
    n_jobs=-1
)
</code></pre>
</div>


    </main>

    
      
    
  </body>
</html>
