<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.119.0">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>基于eggjs, sequelize和pgsql的小需求 &middot; JasonLee</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.jasonleehere.com/"><h1>JasonLee</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.jasonleehere.com/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2023. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>基于eggjs, sequelize和pgsql的小需求</h1>
  <time datetime=2023-09-29T12:13:49Z class="post-date">Fri, Sep 29, 2023</time>
  <h2 id="前言">前言</h2>
<p>这是我在部门遇到的第一个小需求。这一次，我写的是后端代码。刚开始，我还陷入在一种思维定式里，似乎一定要在现有项目的工程里添加代码。如果这样做，就需要在本地或者测试服务器启动项目，然而不熟悉服务器环境和配置的我，容易卡在一个环节上无法继续。我后面想明白了，完全可以将其视作一个独立的小项目。</p>
<h2 id="pgsql-启动入口">pgsql 启动入口</h2>
<p>不同于 mysql 直接通过命令行工具启动，pgsql 的启动方式有两种。一种是自带的 pgadmin4 这款数据库可视化软件，只要第一次连接上，后续打开都会自动连接。另一种是 sql shell, 也是随 pgsql 一起安装的。打开后，前面几个参数都是默认，最后输入口令（密码）。</p>
<p><img src="https://fastly.jsdelivr.net/gh/li199-code/blog-imgs@main/16959671454581695967145365.png" alt="16959671454581695967145365.png"></p>
<h2 id="eggjssequelize-的开发流程">eggjs+sequelize 的开发流程</h2>
<h3 id="初始化-egg-项目和安装-npm-包">初始化 egg 项目和安装 npm 包</h3>
<pre tabindex="0"><code>$ npm init egg --type=simple
$ npm i

# sequelize 和 nodejs的pgsql驱动
npm install --save egg-sequelize pg pg-hstore
</code></pre><h3 id="在-configpluginjs-中引入-egg-sequelize-插件">在 config/plugin.js 中引入 egg-sequelize 插件</h3>
<pre tabindex="0"><code>&#39;use strict&#39;;

exports.sequelize = {
  enable: true,
  package: &#39;egg-sequelize&#39;,
};
</code></pre><h3 id="在-configconfigdefaultjs-中编写-sequelize-配置">在 config/config.default.js 中编写 sequelize 配置</h3>
<pre tabindex="0"><code>/* eslint valid-jsdoc: &#34;off&#34; */

&#39;use strict&#39;;

module.exports = appInfo =&gt; {
  /**
   * built-in config
   * @type {Egg.EggAppConfig}
   **/
  const config = exports = {};

  // use for cookie sign key, should change to your own and keep security
  config.keys = appInfo.name + &#39;_1696034448361_9424&#39;;

  // add your middleware config here
  config.middleware = [];

  // mysql

  // config.sequelize = {
  //   dialect: &#39;mysql&#39;, // support: mysql, mariadb, postgres, mssql
  //   database: &#39;egg-sequelize-example-dev&#39;,
  //   host: &#39;127.0.0.1&#39;,
  //   port: 3306,
  //   username: &#39;root&#39;,
  //   password: &#39;root&#39;,
  // };

  // pgsql

  config.sequelize = {
    database: &#39;egg-sequelize-example-dev&#39;,
    username: &#39;postgres&#39;,
    password: &#39;root&#39;,
    host: &#39;localhost&#39;, // 或者你的数据库主机地址
    port: 5432, // 或者你的数据库端口号
    dialect: &#39;postgres&#39;, // 指定数据库类型为PostgreSQL
  };

  // add your user config here
  const userConfig = {
    // myAppName: &#39;egg&#39;,
  };

  return {
    ...config,
    ...userConfig,
  };
};
</code></pre><h3 id="创建数据库和数据表在-pgadmin4-等工具中写-sql-语句">创建数据库和数据表（在 pgadmin4 等工具中写 sql 语句）</h3>
<pre tabindex="0"><code>CREATE DATABASE IF NOT EXISTS &#39;egg-sequelize-doc-default&#39;;
create table [name];
</code></pre><h3 id="编写-model">编写 model</h3>
<p>注意字段要和数据表中定义的完全一致。这时候，model 可以通过 ctx.model 访问到，在编写 controller 或 service 层时可通过 ide 检查能否找到 model，若不能，检查 typings 文件夹下相应的 index.d.ts 文件，看看名称能否对应上。</p>
<pre tabindex="0"><code># app/model/station.js

&#39;use strict&#39;;

module.exports = (app) =&gt; {
	const { STRING, INTEGER, TEXT, DATE } = app.Sequelize;
	const { DataTypes } = require(&#39;sequelize&#39;);

    const Station = app.model.define(&#39;Station&#39;, {
      id: { type: INTEGER, primaryKey: true, autoIncrement: true },
      name: { type: STRING(30), allowNull: false },
      associated_yard: { type: STRING(30), allowNull: false },
      address: { type: STRING(50) },
      longitude: { type: DataTypes.NUMERIC(5), allowNull: false},
      latitude: { type: DataTypes.NUMERIC(5), allowNull: false },
      province: {type: STRING(32), allowNull: false},
      city: {type: STRING(32), allowNull: false},
      county: { type: STRING(32), allowNull: false },
      tag: { type: DataTypes.ARRAY(DataTypes.TEXT) },
      property_unit: { type: STRING(30) },
      property_contact: { type: STRING(30) },
      property_phone: { type: STRING(11) },
      status: { type: STRING(10), allowNull: false },
      map_induction: { type: DataTypes.BOOLEAN, allowNull: false },
      area: { type: STRING(30) },
      accounting_policy: { type: STRING(30), allowNull: false },
      operating_description: { type: TEXT, allowNull: false },
      comment: { type: TEXT },
      created_at: DATE,
      updated_at: DATE,
    });

    return Station;
};
</code></pre><p>上述代码中需要注意 sequelize 的表名推导问题。在<code>const Station = app.model.define('Station', {...})</code>中，第一个 Station 是模型名称，是 eggjs 中调用 app.model.[name]用到的名称。然后 define 函数中的&rsquo;Station&rsquo;和数据库中的表明存在对应关系，具体的对应规则是：</p>
<ol>
<li>默认的是单数转复数：默认情况下，Sequelize 会将模型的名称转换为复数形式，并将其用作数据库表的名称。比如，station 转成 stations。所以创建表时，应该把表命名为复数形式。</li>
<li>自定义表名：可以在定义模型时明确指定要映射到的表的名称。</li>
</ol>
<pre tabindex="0"><code>const User = sequelize.define(&#39;User&#39;, {
  // 模型属性定义
}, {
  tableName: &#39;custom_users_table&#39; // 自定义表名
});
</code></pre><h3 id="编写-controller-和-service-层在-routerjs-中添加路由">编写 controller 和 service 层，在 router.js 中添加路由。</h3>

</div>


    </main>

    
      
    
  </body>
</html>
