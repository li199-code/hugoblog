<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.119.0">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>JS之Promise &middot; JasonLee</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.jasonleehere.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.jasonleehere.com/"><h1>JasonLee</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.jasonleehere.com/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2023. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>JS之Promise</h1>
  <time datetime=2022-07-26T17:58:45Z class="post-date">Tue, Jul 26, 2022</time>
  <h2 id="为什么需要promise">为什么需要promise</h2>
<p>首先，存在一次异步任务的需求。然后又有了多次异步任务的需求，而多次异步的书写存在函数瀑布问题，不利于阅读和维护：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;First&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Second&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Third&#34;</span>);
</span></span><span style="display:flex;"><span>            }, <span style="color:#ae81ff">3000</span>);
</span></span><span style="display:flex;"><span>        }, <span style="color:#ae81ff">4000</span>);
</span></span><span style="display:flex;"><span>    }, <span style="color:#ae81ff">1000</span>);
</span></span></code></pre></div><p>所以，出现了promise对象，将多次异步代码写成顺序格式而非嵌套格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">print</span>(<span style="color:#a6e22e">delay</span>, <span style="color:#a6e22e">message</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">message</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">resolve</span>();
</span></span><span style="display:flex;"><span>            }, <span style="color:#a6e22e">delay</span>);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">print</span>(<span style="color:#ae81ff">1000</span>, <span style="color:#e6db74">&#34;First&#34;</span>).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">print</span>(<span style="color:#ae81ff">4000</span>, <span style="color:#e6db74">&#34;Second&#34;</span>);
</span></span><span style="display:flex;"><span>    }).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">print</span>(<span style="color:#ae81ff">3000</span>, <span style="color:#e6db74">&#34;Third&#34;</span>);
</span></span><span style="display:flex;"><span>    });
</span></span></code></pre></div><p>因此，异步是异步，promise是promise，异步任务的实现靠的是异步函数，而不是promise，promise仅是改变了书写格式。</p>
<h2 id="promise的状态和结果">promise的状态和结果</h2>
<p>Promise是一个构造函数，它接收一个函数作为形参，实例化一个p对象。相比于普通对象，p对象有两个特殊属性：状态和结果。</p>
<h3 id="状态">状态</h3>
<p>通过在形参函数中调用resolve()和reject()改变状态，并且只能改一次.状态有三种，分别是pending/fullfilled/reject.没执行resolve() or reject()之前的状态是pending。</p>
<h3 id="结果">结果</h3>
<p>通过resolve/reject函数传递参数，改变当前promise对象结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>)=&gt;{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;homo&#39;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">p</span>); <span style="color:#75715e">// state:fullfilled, result:&#39;homo&#39;
</span></span></span></code></pre></div><h2 id="构造函数和then方法">构造函数和then方法</h2>
<!-- raw HTML omitted -->
<p>promise是靠多个then完成异步任务的嵌套的。怎么实现的？then可以注册resolve和reject。若要嵌套，要写成下面这种形式,return一个新的promise，value在异步代码中使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>		<span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>)=&gt;{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// setTimeout(()=&gt;{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 	resolve(&#39;1&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// },500)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>)=&gt;{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>)=&gt;{
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">setTimeout</span>(()=&gt;{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#39; 2&#39;</span>)
</span></span><span style="display:flex;"><span>				})
</span></span><span style="display:flex;"><span>			})
</span></span><span style="display:flex;"><span>		}).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>)=&gt;{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// console.log(value);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		})
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>把promise对象当作一个容器，里面装了一个异步事件，promise对象保证了当前异步事件执行完毕才会执行下一个事件。</p>
<p>这里引用一下知乎的回答：<!-- raw HTML omitted --></p>
<ol>
<li>
<p>构造实例
构造函数接受一个函数作为参数
调用构造函数得到实例p的同时，作为参数的函数会立即执行
参数函数接受两个回调函数参数resolve和reject
在参数函数被执行的过程中，如果在其内部调用resolve，会将p的状态变成fulfilled，或者调用reject，会将p的状态变成rejected</p>
</li>
<li>
<p>调用.then
调用.then可以为实例p注册两种状态回调函数
当实例p的状态为fulfilled，会触发第一个函数执行
当实例p的状态为rejected，则触发第二个函数执行</p>
</li>
</ol>
<p>如果代码执行出现错误，而没有catch或者then接受错误的话，控制台会报错。</p>
<p>下面的代码可以充分体现了，promise对象解决了异步函数的多重回调问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#f92672">&lt;!</span><span style="color:#a6e22e">DOCTYPE</span> <span style="color:#a6e22e">html</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">html</span> <span style="color:#a6e22e">lang</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;en&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">head</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">meta</span> <span style="color:#a6e22e">charset</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UTF-8&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">meta</span> <span style="color:#a6e22e">http</span><span style="color:#f92672">-</span><span style="color:#a6e22e">equiv</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;X-UA-Compatible&#34;</span> <span style="color:#a6e22e">content</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;IE=edge&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">meta</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;viewport&#34;</span> <span style="color:#a6e22e">content</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;width=device-width, initial-scale=1.0&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">title</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Document</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/title&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/head&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">body</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">script</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&#34;</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">/script&gt;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">script</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getData</span>(<span style="color:#a6e22e">url</span>, <span style="color:#a6e22e">data</span><span style="color:#f92672">=</span>{}){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>)=&gt;{
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">ajax</span>({
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">type</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#39;GET&#39;</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">url</span><span style="color:#f92672">:</span><span style="color:#a6e22e">url</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">data</span><span style="color:#f92672">:</span><span style="color:#a6e22e">data</span>,
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">success</span><span style="color:#f92672">:</span><span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">res</span>){
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">const</span> {<span style="color:#a6e22e">result</span>} <span style="color:#f92672">=</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>						<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>						<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">result</span>)
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>				})
</span></span><span style="display:flex;"><span>			})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">getData</span>(<span style="color:#e6db74">&#39;data1.json&#39;</span>).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>)=&gt;{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">getData</span>(<span style="color:#e6db74">&#39;data2.json&#39;</span>, <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>		} ) 
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/script&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/body&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/html&gt;</span>
</span></span></code></pre></div><h2 id="promiseall">Promise.all()</h2>
<p>作用：一次接受多个异步事件，并保证他们的都得到结果了，才会执行then
输入参数：数组、map等
输出：一个新的promise对象，根据数组中所有promise的执行结果而进入不同的函数。若数组中所有的promise都是fullfilled，则会执行then。</p>
<h2 id="promiseany">Promise.any()</h2>
<p>作用：一次接受多个异步事件，其中有一个成功就行
输入参数：数组、map等</p>
<h2 id="promiseresolveprejectp">Promise.resolve(p)/reject(p)</h2>
<p>返回一个状态为fullfilled/rejected,结果为p的promise对象。</p>
</div>


    </main>

    
      
    
  </body>
</html>
